<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <!-- Page Title -->
  <title>Countdown</title>
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png">
  
  <!-- Apple Touch Icons for iPhone -->
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
  
  <!-- PWA Meta Tags for iPhone Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Countdown">
  <meta name="theme-color" content="#141414">
  
  <!-- React & Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #root {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

const LiquidGlassCountdown = () => {
  const [targetTime, setTargetTime] = useState('');
  const [timeLeft, setTimeLeft] = useState(null);
  const [isActive, setIsActive] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const svgRef = useRef(null);
  const canvasRefs = useRef([]);
  const containerRefs = useRef([]);
  const filterId = useRef(`liquid-glass-${Math.random().toString(36).substr(2, 9)}`);
  const animationFrameRef = useRef(null);

  // Utility functions for liquid glass effect
  const smoothStep = (a, b, t) => {
    t = Math.max(0, Math.min(1, (t - a) / (b - a)));
    return t * t * (3 - 2 * t);
  };

  const length = (x, y) => Math.sqrt(x * x + y * y);

  const roundedRectSDF = (x, y, width, height, radius) => {
    const qx = Math.abs(x) - width + radius;
    const qy = Math.abs(y) - height + radius;
    return Math.min(Math.max(qx, qy), 0) + length(Math.max(qx, 0), Math.max(qy, 0)) - radius;
  };

  const updateShader = (index) => {
    const canvas = canvasRefs.current[index];
    const container = containerRefs.current[index];
    if (!canvas || !container) return;

    const rect = container.getBoundingClientRect();
    const w = Math.floor(rect.width);
    const h = Math.floor(rect.height);
    
    // Ensure dimensions are valid
    if (w <= 0 || h <= 0 || !isFinite(w) || !isFinite(h)) return;
    
    canvas.width = w;
    canvas.height = h;
    
    const ctx = canvas.getContext('2d');
    const data = new Uint8ClampedArray(w * h * 4);

    let maxScale = 0;
    const rawValues = [];

    for (let i = 0; i < data.length; i += 4) {
      const x = (i / 4) % w;
      const y = Math.floor(i / 4 / w);
      const uvX = x / w;
      const uvY = y / h;
      
      const ix = uvX - 0.5;
      const iy = uvY - 0.5;
      const distanceToEdge = roundedRectSDF(ix, iy, 0.35, 0.25, 0.5);
      const displacement = smoothStep(0.8, 0, distanceToEdge - 0.12);
      const scaled = smoothStep(0, 1, displacement);
      
      const posX = ix * scaled + 0.5;
      const posY = iy * scaled + 0.5;
      
      const dx = posX * w - x;
      const dy = posY * h - y;
      maxScale = Math.max(maxScale, Math.abs(dx), Math.abs(dy));
      rawValues.push(dx, dy);
    }

    maxScale *= 0.5;

    let idx = 0;
    for (let i = 0; i < data.length; i += 4) {
      const r = rawValues[idx++] / maxScale + 0.5;
      const g = rawValues[idx++] / maxScale + 0.5;
      data[i] = r * 255;
      data[i + 1] = g * 255;
      data[i + 2] = 0;
      data[i + 3] = 255;
    }

    ctx.putImageData(new ImageData(data, w, h), 0, 0);
    
    const feImage = document.getElementById(`${filterId.current}_map_${index}`);
    const feDisplacementMap = document.getElementById(`${filterId.current}_displacement_${index}`);
    
    if (feImage && feDisplacementMap) {
      feImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', canvas.toDataURL());
      feDisplacementMap.setAttribute('scale', maxScale.toString());
    }
  };

  useEffect(() => {
    const handleResize = () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      animationFrameRef.current = requestAnimationFrame(() => {
        [0, 1, 2].forEach(i => updateShader(i));
      });
    };

    // Delay initial shader update to ensure container is rendered
    const timeoutId = setTimeout(() => {
      [0, 1, 2].forEach(i => updateShader(i));
    }, 100);
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener('resize', handleResize);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  useEffect(() => {
    let interval = null;

    if (isActive && !isPaused && targetTime) {
      interval = setInterval(() => {
        const now = new Date();
        const target = new Date();
        const [hours, minutes] = targetTime.split(':');
        target.setHours(parseInt(hours), parseInt(minutes), 0, 0);

        if (target <= now) {
          target.setDate(target.getDate() + 1);
        }

        const diff = target - now;

        if (diff <= 0) {
          setIsActive(false);
          setTimeLeft({ hours: 0, minutes: 0, seconds: 0 });
          return;
        }

        const h = Math.floor(diff / (1000 * 60 * 60));
        const m = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const s = Math.floor((diff % (1000 * 60)) / 1000);

        setTimeLeft({ hours: h, minutes: m, seconds: s });
      }, 100);
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isActive, isPaused, targetTime]);

  const handleStart = () => {
    if (!targetTime) return;
    setIsActive(true);
    setIsPaused(false);
  };

  const handlePause = () => {
    setIsPaused(!isPaused);
  };

  const handleRestart = () => {
    setIsActive(false);
    setIsPaused(false);
    setTimeLeft(null);
    setTargetTime('');
  };

  const formatTime = (value) => String(value).padStart(2, '0');

  const timeUnits = [
    { value: timeLeft?.hours ?? 0, label: 'HOURS' },
    { value: timeLeft?.minutes ?? 0, label: 'MINUTES' },
    { value: timeLeft?.seconds ?? 0, label: 'SECONDS' }
  ];

  return (
    <div style={{
      width: '100vw',
      height: '100vh',
      backgroundColor: '#141414',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      position: 'relative',
      overflow: 'hidden',
      padding: '20px',
      boxSizing: 'border-box'
    }}>
      {/* Hidden SVG for filters */}
      <svg
        ref={svgRef}
        xmlns="http://www.w3.org/2000/svg"
        style={{
          position: 'absolute',
          width: 0,
          height: 0,
          pointerEvents: 'none'
        }}
      >
        <defs>
          {[0, 1, 2].map(i => (
            <filter
              key={i}
              id={`${filterId.current}_${i}`}
              filterUnits="userSpaceOnUse"
              colorInterpolationFilters="sRGB"
            >
              <feImage
                id={`${filterId.current}_map_${i}`}
                preserveAspectRatio="none"
              />
              <feDisplacementMap
                id={`${filterId.current}_displacement_${i}`}
                in="SourceGraphic"
                in2={`${filterId.current}_map_${i}`}
                xChannelSelector="R"
                yChannelSelector="G"
                scale="20"
              />
            </filter>
          ))}
        </defs>
      </svg>

      {/* Hidden canvases for displacement maps */}
      {[0, 1, 2].map(i => (
        <canvas
          key={i}
          ref={el => canvasRefs.current[i] = el}
          style={{ display: 'none' }}
        />
      ))}

      {!isActive ? (
        /* Time Input Screen */
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '30px',
          width: '100%',
          maxWidth: '600px'
        }}>
          <input
            type="time"
            value={targetTime}
            onChange={(e) => setTargetTime(e.target.value)}
            style={{
              width: '100%',
              padding: '20px 24px',
              fontSize: '20px',
              fontWeight: '700',
              backgroundColor: '#2a2a2a',
              border: '2px solid #3a3a3a',
              borderRadius: '16px',
              color: '#ffffff',
              outline: 'none',
              fontFamily: 'inherit',
              cursor: 'pointer',
              boxSizing: 'border-box'
            }}
          />
          <button
            onClick={handleStart}
            disabled={!targetTime}
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
              padding: '16px 32px',
              fontSize: '16px',
              fontWeight: '700',
              backgroundColor: '#ffffff',
              color: '#141414',
              border: 'none',
              borderRadius: '12px',
              cursor: targetTime ? 'pointer' : 'not-allowed',
              transition: 'all 0.2s',
              opacity: targetTime ? 1 : 0.5
            }}
          >
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7z"/>
            </svg>
            Start
          </button>
        </div>
      ) : (
        /* Countdown Display */
        <>
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 'min(3vw, 20px)',
            marginBottom: '60px',
            flexWrap: 'nowrap',
            width: '100%',
            maxWidth: '1200px',
            overflowX: 'auto'
          }}>
            {timeUnits.map((unit, index) => (
              <React.Fragment key={unit.label}>
                <div
                  ref={el => containerRefs.current[index] = el}
                  style={{
                    position: 'relative',
                    width: 'min(28vw, 340px)',
                    height: 'min(28vw, 340px)',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    borderRadius: '24px',
                    overflow: 'hidden',
                    backgroundColor: '#3a3a3a',
                    boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                    backdropFilter: `url(#${filterId.current}_${index}) blur(0.5px) contrast(1.15) brightness(1.08) saturate(1.12)`,
                    WebkitBackdropFilter: `url(#${filterId.current}_${index}) blur(0.5px) contrast(1.15) brightness(1.08) saturate(1.12)`
                  }}
                >
                  <div style={{
                    fontSize: 'min(18vw, 180px)',
                    fontWeight: '700',
                    color: '#ffffff',
                    letterSpacing: '-0.02em',
                    lineHeight: 1,
                    fontVariantNumeric: 'tabular-nums'
                  }}>
                    {formatTime(unit.value)}
                  </div>
                  <div style={{
                    fontSize: 'min(2.5vw, 14px)',
                    fontWeight: '600',
                    color: '#888888',
                    letterSpacing: '0.1em',
                    marginTop: '12px',
                    textTransform: 'uppercase'
                  }}>
                    {unit.label}
                  </div>
                </div>
                {index < 2 && (
                  <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '12px'
                  }}>
                    <div style={{
                      width: 'min(2vw, 12px)',
                      height: 'min(2vw, 12px)',
                      borderRadius: '50%',
                      backgroundColor: '#555555'
                    }} />
                    <div style={{
                      width: 'min(2vw, 12px)',
                      height: 'min(2vw, 12px)',
                      borderRadius: '50%',
                      backgroundColor: '#555555'
                    }} />
                  </div>
                )}
              </React.Fragment>
            ))}
          </div>

          {/* Target Time Display */}
          <div style={{
            fontSize: '14px',
            color: '#666666',
            marginBottom: '30px',
            fontWeight: '700'
          }}>
            Target: {targetTime}
          </div>

          {/* Control Buttons */}
          <div style={{
            display: 'flex',
            gap: '16px',
            alignItems: 'center'
          }}>
            <button
              onClick={handlePause}
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '8px',
                padding: '14px 28px',
                fontSize: '15px',
                fontWeight: '700',
                backgroundColor: '#ffffff',
                color: '#141414',
                border: 'none',
                borderRadius: '12px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
            >
              {isPaused ? (
                <>
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M8 5v14l11-7z"/>
                  </svg>
                  Resume
                </>
              ) : (
                <>
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                  </svg>
                  Pause
                </>
              )}
            </button>
            <button
              onClick={handleRestart}
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                padding: '14px',
                fontSize: '15px',
                fontWeight: '700',
                backgroundColor: '#2a2a2a',
                color: '#ffffff',
                border: 'none',
                borderRadius: '12px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
              </svg>
            </button>
          </div>
        </>
      )}
    </div>
  );
};

// Render the component
ReactDOM.createRoot(document.getElementById('root')).render(<LiquidGlassCountdown />);
  </script>
</body>
</html>